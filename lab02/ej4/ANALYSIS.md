# Análisis de los diferentes algoritmos de ordenación

A través de los diferentes casos de prueba, corriendo los distintos algoritmos sobre los archivos de la carpeta `/input`, podemos observar que:
- El algoritmo de ordenación por selección, `selection sort`, crece de forma constante en base a cuantos elementos tenga el arreglo que queramos ordenar. Realiza **n** intercambios y realiza **n(n - 1)/2** comparaciones. Por lo que, al igual que lo visto en el teórico, es del orden **n^2**. Suele ser el algoritmos más lento, pero no lo es siempre.
- El algoritmo de ordenación por inserción, `insertion sort`, realiza una cantidad de intercambios y comparaciones muy similar por lo que puede, en casos de arreglos muy grandes, ser menos eficiente que el algoritmo anterior. En los casos que se probaron, el orden se asienta sobre **n^2**, pero se acercaron más a un número como **(n^2)/4**. No fue el más rápido, pero supera al primer algoritmo en la mayoría de los casos.
- El algoritmo de ordenación rápida, `quick sort`, suele ser el que menos comparaciones ejecuta, pero se sitúa entre los algoritmos anteriores en cuanto a intercambios. Es por lejos el más rápido de los algoritmos, siendo casi un 100% más rápido (0.4 s vs 400 s) que los demás algoritmos ordenando un arreglo de 10.000 elementos. Su "talón de Aquiles" resultan ser aquellos arreglos ordenados al revés, de mayor a menor, realizando más comparaciones que ambos algoritmos anteriores y quedando entre ellos en cuanto a tiempo de ejecución.

En general, los tres algoritmos son eficaces, pero podemos destacar a `quick sort` como el algoritmo más eficiente en la mayoría de los casos en cuanto a tiempo de ejecución y cantidad de comparaciones, pero supera ampliamente en cantidad de intercambios a `selection sort`, que si bien no es el mejor, suele ser el más consistente en todos los casos que ejecuta. El `insertion sort` es más rápido que el `selection sort` en la mayoría de los casos, pero realiza una cantidad mucho mayor de intercambios que éste. 